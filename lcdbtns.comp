/********************************************************************************
lcdbtns.comp

Serial communications with the LCD Button Panel in a userspace component

*********************************************************************************/

component lcdbtns "This component services the LCD Button Panel";

// these LEDs correspond to the current axis and speed
pin in bit xenabled;
pin in bit yenabled;
pin in bit zenabled;
pin in bit lowscaleenable;
pin in bit midscaleenable;
pin in bit highscaleenable;

// These correspond to the pins defined by gmocappy
pin out bit v_button_0;
pin out bit v_button_1;
pin out bit v_button_2;
pin out bit v_button_3;
pin out bit v_button_4;
pin out bit v_button_5;
pin out bit v_button_6;

pin out bit h_button_0;
pin out bit h_button_1;
pin out bit h_button_2;
pin out bit h_button_3;
pin out bit h_button_4;
pin out bit h_button_5;
pin out bit h_button_6;
pin out bit h_button_7;
pin out bit h_button_8;
pin out bit h_button_9;

pin out bit button_spindle;
pin out bit button_bonus;

pin out float jog_velocity;
pin out float feed_override;
pin out float spindle_override;
pin out float rapid_override;

pin out bit connected;

option userspace yes;
option extra_cleanup;
option singleton yes;

author "Nathan Tsoi";
license "MIT";
;;

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <termios.h>
#include <sys/ioctl.h>
#include <sys/time.h>

#define BAUDRATE B230400
#define DEVICE "/dev/serial/by-id/usb-STMicroelectronics_GENERIC_F103CBTX_CDC_in_FS_Mode_8D7E43605351-if00"
#define _POSIX_SOURCE 1
#define SERIAL_BUFFER_SIZE 64

// predefs of later functions
// int serialport_init();

int set_interface_attribs(int fd, int speed, int parity)
{
    struct termios tty;
    if (tcgetattr(fd, &tty) != 0)
    {
        fprintf(stderr, "error %d from tcgetattr", errno);
        return -1;
    }

    cfsetospeed(&tty, speed);
    cfsetispeed(&tty, speed);

    tty.c_cflag = (tty.c_cflag & ~CSIZE) | CS8; // 8-bit chars
    // disable IGNBRK for mismatched speed tests; otherwise receive break
    // as \000 chars
    tty.c_iflag &= ~IGNBRK; // disable break processing
    tty.c_lflag = 0;        // no signaling chars, no echo,
                            // no canonical processing
    tty.c_oflag = 0;        // no remapping, no delays
    tty.c_cc[VMIN] = 0;     // read doesn't block
    tty.c_cc[VTIME] = 5;    // 0.5 seconds read timeout

    tty.c_iflag &= ~(IXON | IXOFF | IXANY); // shut off xon/xoff ctrl

    tty.c_cflag |= (CLOCAL | CREAD);   // ignore modem controls,
                                       // enable reading
    tty.c_cflag &= ~(PARENB | PARODD); // shut off parity
    tty.c_cflag |= parity;
    tty.c_cflag &= ~CSTOPB;
    tty.c_cflag &= ~CRTSCTS;

    if (tcsetattr(fd, TCSANOW, &tty) != 0)
    {
        fprintf(stderr, "error %d from tcsetattr", errno);
        return -1;
    }
    return 0;
}

void set_blocking(int fd, int should_block)
{
    struct termios tty;
    memset(&tty, 0, sizeof tty);
    if (tcgetattr(fd, &tty) != 0)
    {
        fprintf(stderr, "error %d from tggetattr", errno);
        return;
    }

    tty.c_cc[VMIN] = should_block ? 1 : 0;
    tty.c_cc[VTIME] = 5; // 0.5 seconds read timeout

    if (tcsetattr(fd, TCSANOW, &tty) != 0)
        fprintf(stderr, "error %d setting term attributes", errno);
}

char out_buffer[SERIAL_BUFFER_SIZE];
char serial_buffer[SERIAL_BUFFER_SIZE];
char serial_buffer_start = 0;
char serial_buffer_end = 0;

void write_led_states(int fd)
{
    FOR_ALL_INSTS()
    {
        sprintf(out_buffer, "l%d%d%d%d%d%d\n", xenabled, yenabled, zenabled, lowscaleenable, midscaleenable, highscaleenable);
    }
    //printf("SENDING %s\n", out_buffer);
    write(fd, out_buffer, strlen(out_buffer));
}

bool fill_serial_buffer(int fd)
{
    char c = 0;
    // Fill the ros serial buffer if we have data
    while (read(fd, &c, 1) > 0)
    {
        //printf("LCDBTNS got a char %c\n", c);
        if (c == '\n')
        {
            break;
        }
        // fill the ring buffer
        serial_buffer[serial_buffer_end++] = c;
        if (serial_buffer_end >= SERIAL_BUFFER_SIZE)
        {
            serial_buffer_end = 0;
        }
    }
    return c == '\n';
}

char read_serial_buffer()
{
    char c = serial_buffer[serial_buffer_start++];
    if (serial_buffer_start >= SERIAL_BUFFER_SIZE)
    {
        serial_buffer_start = 0;
    }
    return c;
}

bool read_btn()
{
    return read_serial_buffer() == '1';
}

int read_adc()
{
    // adc returns a 4 digit number
    char intstr[5];
    for (int i = 0; i < 4; i++)
    {
        intstr[i] = read_serial_buffer();
    }
    return atoi(intstr);
}

void parse_serial_buffer()
{
    if (read_serial_buffer() != 'b')
    {
        perror("bad serial buffer");
        return;
    }
    //printf("LCDBTNS got a buffer\n");
    FOR_ALL_INSTS()
    {
        // read order must match the sending order in the microcontroller code
        button_spindle = read_btn();
        button_bonus = read_btn();
        v_button_0 = read_btn();
        v_button_1 = read_btn();
        v_button_2 = read_btn();
        v_button_3 = read_btn();
        v_button_4 = read_btn();
        v_button_5 = read_btn();
        v_button_6 = read_btn();
        h_button_0 = read_btn();
        h_button_1 = read_btn();
        h_button_2 = read_btn();
        h_button_3 = read_btn();
        h_button_4 = read_btn();
        h_button_5 = read_btn();
        h_button_6 = read_btn();
        h_button_7 = read_btn();
        h_button_8 = read_btn();
        h_button_9 = read_btn();

        jog_velocity = 1 - read_adc() / 4033.0f;
        feed_override = 1 - read_adc() / 4033.0f;
        spindle_override = 1 - read_adc() / 4033.0f;
        rapid_override = 1 - read_adc() / 4033.0f;

        //printf("LCDBTNS analog values %f %f %f %f\n", jog_velocity, feed_override, spindle_override, rapid_override);
    }
}

// port setup
struct termios toptions;

#define SLEEPTIME_US 10
#define RECONNECT_DELAY_MS 1000

int connect() {
    // int fd = serialport_init();
    printf("LCDBTNS opening %s\n", DEVICE);
    int fd = open(DEVICE, O_RDWR | O_NOCTTY | O_SYNC);
    if (fd < 0)
    {
        fprintf(stderr, "LCDBTNS error %d opening %s: %s", errno, DEVICE, strerror(errno));
        return -1;
    }
    set_interface_attribs(fd, BAUDRATE, 0); // set speed, 8n1 (no parity)
    set_blocking(fd, 0);
    return fd;
}

int fd = -1;

EXTRA_CLEANUP() {
    if (fd >= 0) {
        close(fd);
        fprintf(stderr, "closed serial port");
    }
}

void user_mainloop(void)
{
    printf("LCDBTNS starting.\n");

    while (1) {
        usleep(SLEEPTIME_US);
        if (fd < 0) {
            printf("LCDBTNS connecting\n");
            fd = connect();
            if (fd < 0) {
                FOR_ALL_INSTS() connected = 0;
                usleep(RECONNECT_DELAY_MS * 1000);
                continue;
            }
            printf("LCDBTNS connected\n");
            FOR_ALL_INSTS() connected = 1;
        }  
        write_led_states(fd);
        if (fill_serial_buffer(fd))
        {
            parse_serial_buffer();
        }
    }

    exit(0);
}